From bb406a6aea336966681927a27f54ee89c4fd4ea1 Mon Sep 17 00:00:00 2001
From: Richard Biener <rguenther@suse.de>
Date: Mon, 24 Apr 2023 13:31:07 +0200
Subject: [PATCH] rtl-optimization/109585 - alias analysis typo

When r10-514-gc6b84edb6110dd2b4fb improved access path analysis
it introduced a typo that triggers when there's an access to a
trailing array in the first access path leading to false
disambiguation.

	PR rtl-optimization/109585
	* tree-ssa-alias.cc (aliasing_component_refs_p): Fix typo.

	* gcc.dg/torture/pr109585.c: New testcase.

(cherry picked from commit 6d4bd27a60447c7505cb4783e675e98a191a8904)
---
 gcc/testsuite/gcc.dg/torture/pr109585.c | 33 +++++++++++++++++++++++++
 gcc/tree-ssa-alias.cc                   |  2 +-
 2 files changed, 34 insertions(+), 1 deletion(-)
 create mode 100644 gcc/testsuite/gcc.dg/torture/pr109585.c

--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr109585.c
@@ -0,0 +1,33 @@
+/* { dg-do run } */
+
+#include <stdlib.h>
+
+struct P {
+    long v;
+    struct P *n;
+};
+
+struct F {
+    long x;
+    struct P fam[];
+};
+
+int __attribute__((noipa))
+f(struct F *f, int i)
+{
+  struct P *p = f->fam;
+  asm("" : "+r"(f): "r"(p));
+  p->v = 0;
+  p->n = 0;
+  return f->fam->n != 0;
+}
+
+int
+main()
+{
+  struct F *m = malloc (sizeof (long) + 2 * sizeof (struct P));
+  m->fam[0].n = &m->fam[1];
+  if (f (m, 0))
+    abort ();
+  return 0;
+}
--- a/gcc/tree-ssa-alias.cc
+++ b/gcc/tree-ssa-alias.cc
@@ -1330,7 +1330,7 @@ aliasing_component_refs_p (tree ref1,
   /* If we didn't find a common base, try the other way around.  */
   if (cmp_outer <= 0 
       || (end_struct_ref1
-	  && compare_type_sizes (TREE_TYPE (end_struct_ref1), type1) <= 0))
+	  && compare_type_sizes (TREE_TYPE (end_struct_ref1), type2) <= 0))
     {
       int res = aliasing_component_refs_walk (ref2, type2, base2,
 					      offset2, max_size2,
